{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/coinbase/Coinbase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../modules/sht-module/SHTModule.sol\";\nimport \"../project-funding/ProjectFunding.sol\";\n\n/**\n * @title Coinbase\n * @dev This contract is used to start the ICO for housing projects.\n */\ncontract Coinbase is Ownable, SHTModule {\n\tusing SafeMath for uint256;\n\n\tconstructor() ERC20(\"SmartHousingToken\", \"SHT\") {\n\t\t_mint(address(this), SHT.MAX_SUPPLY);\n\t}\n\n\t/**\n\t * @dev Starts the ICO by initializing the first housing project.\n\t * @param projectFundingAddr Address of the ProjectFunding contract.\n\t * @param smartHousingAddress Address of the SmartHousing contract.\n\t * @param fundingToken Address of the funding token (ERC20).\n\t * @param fundingGoal The funding goal for the new project.\n\t * @param fundingDeadline The deadline for the project funding.\n\t */\n\tfunction startICO(\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\taddress projectFundingAddr,\n\t\taddress smartHousingAddress,\n\t\taddress fundingToken,\n\t\tuint256 fundingGoal,\n\t\tuint256 fundingDeadline\n\t) external onlyOwner {\n\t\tERC20TokenPayment memory icoPayment = _makeSHTPayment(SHT.ICO_FUNDS);\n\n\t\t_approve(address(this), projectFundingAddr, icoPayment.amount);\n\n\t\tProjectFunding(projectFundingAddr).initFirstProject(\n\t\t\ticoPayment,\n\t\t\tname,\n\t\t\tsymbol,\n\t\t\tsmartHousingAddress,\n\t\t\tfundingToken,\n\t\t\tfundingGoal,\n\t\t\tfundingDeadline\n\t\t);\n\t}\n\n\t/**\n\t * @dev Dispatches ecosystem funds if not already dispatched to SmartHousing contract.\n\t * @param smartHousingAddr The address of the SmartHousing contract.\n\t */\n\tfunction feedSmartHousing(address smartHousingAddr) external onlyOwner {\n\t\tERC20TokenPayment memory feedPayment = _makeSHTPayment(\n\t\t\tSHT.ECOSYSTEM_DISTRIBUTION_FUNDS\n\t\t);\n\n\t\t// Ensure data integrity\n\t\trequire(\n\t\t\tbalanceOf(address(this)) >= feedPayment.amount,\n\t\t\t\"Already dispatched\"\n\t\t);\n\n\t\t_approve(address(this), smartHousingAddr, feedPayment.amount);\n\n\t\tISmartHousing(smartHousingAddr).setUpSHT(feedPayment);\n\t}\n}\n"
    },
    "contracts/housing-project/CallsSmartHousing.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.24;\n\nimport \"../main/Interface.sol\";\n\nabstract contract CallsSmartHousing {\n\t/// @notice The address of the main SmartHousing contract.\n\taddress immutable smartHousingAddr;\n\n\tconstructor(address smartHousingAddr_) {\n\t\tsmartHousingAddr = smartHousingAddr_;\n\t}\n\n\t/// @dev Gets the referrer address for a given original owner.\n\t/// @param userAddr The original owner of the token.\n\t/// @return The referrer address.\n\tfunction getReferrer(\n\t\taddress userAddr\n\t) internal view returns (uint, address) {\n\t\treturn IUserModule(smartHousingAddr).getReferrer(userAddr);\n\t}\n}\n"
    },
    "contracts/housing-project/HousingProject.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./RentsModule.sol\";\n\n/// @title HousingProject Contract\n/// @notice Represents a unique real estate project within the SmartHousing ecosystem.\n/// @dev This contract inherits from RentsModule and HousingSFT.\ncontract HousingProject is RentsModule, Ownable {\n\t/// @notice Initializes the HousingProject contract.\n\t/// @param smartHousingAddr The address of the main SmartHousing contract.\n\tconstructor(\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\taddress smartHousingAddr\n\t) CallsSmartHousing(smartHousingAddr) {\n\t\tprojectSFT = new HousingSFT(name, symbol);\n\t}\n\n\tevent TokenIssued(address tokenAddress, string name, uint256 amountRaised);\n\n\tfunction setTokenDetails(\n\t\tuint256 amountRaised,\n\t\taddress housingTokenAddr\n\t) external onlyOwner {\n\t\trequire(amountRaised == 0, \"Token details set already\");\n\n\t\thousingToken = ERC20Burnable(housingTokenAddr);\n\n\t\tprojectSFT.setAmountRaised(amountRaised);\n\t\tstring memory name = projectSFT.name();\n\n\t\temit TokenIssued(address(projectSFT), name, amountRaised);\n\t}\n\n\tfunction getMaxSupply() public view returns (uint256) {\n\t\treturn projectSFT.getMaxSupply();\n\t}\n}\n"
    },
    "contracts/housing-project/HousingSFT.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../modules/SFT.sol\";\n\nstruct HousingAttributes {\n\tuint256 rewardsPerShare;\n\taddress originalOwner;\n\tuint256 tokenWeight;\n}\n\n/// @title Housing SFT\n/// @notice This contract represents a semi-fungible token (SFT) for housing projects.\n/// @dev This contract will be inherited by the HousingProject contract.\ncontract HousingSFT is SFT {\n\tusing EnumerableSet for EnumerableSet.UintSet;\n\n\tstruct HousingSFTBalance {\n\t\tuint256 nonce;\n\t\tuint256 amount;\n\t\tHousingAttributes attributes;\n\t}\n\n\t// FIXME this value should be unique to each contract, should depend on\n\t// the total amount expected to raise as it determines the amount of SFTs to\n\t// be minted for investors\n\tuint256 public constant MAX_SUPPLY = 1_000_000;\n\n\t/// @notice The amount of fungible tokens collected from investors to finance the development of this housing project.\n\tuint256 public amountRaised;\n\n\t/// @notice The current amount out of the `MAX_SUPPLY` of tokens minted.\n\tuint256 public totalSupply;\n\n\tconstructor(\n\t\tstring memory name_,\n\t\tstring memory symbol_\n\t) SFT(name_, symbol_) {}\n\n\tfunction setAmountRaised(uint256 amountRaised_) external onlyOwner {\n\t\tamountRaised = amountRaised_;\n\t}\n\n\tmodifier canMint() {\n\t\taddress sftOwner = owner();\n\n\t\trequire(\n\t\t\tOwnable(sftOwner).owner() == _msgSender(),\n\t\t\t\"not allowed to mint\"\n\t\t);\n\n\t\t_;\n\t}\n\n\t/// @notice Mints SFT tokens for a depositor based on the amount of deposit.\n\t/// @param depositAmt The amount of fungible token deposited.\n\t/// @param depositor The address of the depositor.\n\tfunction mintSFT(\n\t\tuint256 depositAmt,\n\t\taddress depositor,\n\t\tuint256 amount_raised\n\t) external canMint returns (uint256) {\n\t\t// TODO remove after demo due to not beign able to move blocks in public networks\n\t\t{\n\t\t\tamountRaised = amount_raised;\n\t\t}\n\n\t\tuint256 totalDeposits = amountRaised;\n\t\tuint256 maxShares = MAX_SUPPLY;\n\n\t\trequire(totalDeposits > 0, \"HousingSFT: No deposits recorded\");\n\n\t\tuint256 mintShare = (depositAmt * maxShares) / totalDeposits;\n\t\trequire(mintShare > 0, \"HousingSFT: Computed token shares is invalid\");\n\n\t\ttotalSupply += mintShare;\n\t\trequire(totalSupply <= MAX_SUPPLY, \"HousingSFT: Max supply exceeded\");\n\n\t\tbytes memory attributes = abi.encode(\n\t\t\tHousingAttributes({\n\t\t\t\trewardsPerShare: 0, // Should be 0 since they have never claimed any rent rewards\n\t\t\t\toriginalOwner: depositor,\n\t\t\t\ttokenWeight: mintShare\n\t\t\t})\n\t\t);\n\n\t\treturn _mint(depositor, mintShare, attributes, \"\");\n\t}\n\n\t/// @notice Checks if an address owns this HousingSFT and returns the attributes.\n\t/// @param owner The address to check the balance of.\n\t/// @return `HousingAttributes` if the owner has a positive balance of the token, panics otherwise.\n\tfunction getUserSFT(\n\t\taddress owner,\n\t\tuint256 nonce\n\t) public view returns (HousingAttributes memory) {\n\t\trequire(\n\t\t\thasSFT(owner, nonce),\n\t\t\t\"HouisingSFT: No tokens found for user at nonce\"\n\t\t);\n\n\t\treturn abi.decode(getRawTokenAttributes(nonce), (HousingAttributes));\n\t}\n\n\tfunction getMaxSupply() public pure returns (uint256) {\n\t\treturn MAX_SUPPLY;\n\t}\n\n\tfunction sftBalance(\n\t\taddress user\n\t) public view returns (HousingSFTBalance[] memory) {\n\t\tSftBalance[] memory _sftBals = _sftBalance(user);\n\t\tHousingSFTBalance[] memory balance = new HousingSFTBalance[](\n\t\t\t_sftBals.length\n\t\t);\n\n\t\tfor (uint256 i; i < _sftBals.length; i++) {\n\t\t\tSftBalance memory _sftBal = _sftBals[i];\n\n\t\t\tbalance[i] = HousingSFTBalance({\n\t\t\t\tnonce: _sftBal.nonce,\n\t\t\t\tamount: _sftBal.amount,\n\t\t\t\tattributes: abi.decode(_sftBal.attributes, (HousingAttributes))\n\t\t\t});\n\t\t}\n\n\t\treturn balance;\n\t}\n\n\tfunction tokenDetails()\n\t\tpublic\n\t\tview\n\t\treturns (string memory, string memory, uint256)\n\t{\n\t\treturn (name(), symbol(), getMaxSupply());\n\t}\n}\n"
    },
    "contracts/housing-project/RentsModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"./HousingSFT.sol\";\nimport \"./RewardSharing.sol\";\nimport \"../lib/TokenPayments.sol\";\nimport \"./CallsSmartHousing.sol\";\n\n/// @title Rents Module\n/// @notice Handles rent payments, reward calculations, and distribution for Housing projects.\n/// @dev This abstract contract should be inherited by the HousingProject contract.\nabstract contract RentsModule is CallsSmartHousing {\n\tusing TokenPayments for ERC20TokenPayment;\n\tusing RewardShares for rewardshares;\n\n\tuint256 public rewardPerShare;\n\tuint256 public rewardsReserve;\n\tuint256 public facilityManagementFunds;\n\n\tERC20Burnable housingToken;\n\tHousingSFT public projectSFT;\n\n\t/// @notice Receives rent payments and distributes rewards.\n\t/// @param rentPayment The details of the rent payment.\n\tfunction receiveRent(ERC20TokenPayment calldata rentPayment) external {\n\t\t// TODO set the appropriate rent per Project\n\t\trequire(\n\t\t\trentPayment.amount > 0,\n\t\t\t\"RentsModule: Insufficient amount\"\n\t\t);\n\t\trequire(\n\t\t\trentPayment.token == housingToken,\n\t\t\t\"RentsModule: Invalid rent payment token\"\n\t\t);\n\t\trentPayment.receiveERC20();\n\n\t\tuint256 rentReward = (rentPayment.amount * 75) / 100;\n\t\tuint256 ecosystemReward = (rentPayment.amount * 18) / 100;\n\t\tuint256 facilityReward = (rentPayment.amount * 7) / 100;\n\n\t\tuint256 allShares = projectSFT.getMaxSupply();\n\t\tuint256 rpsIncrease = (rentReward * DIVISION_SAFETY_CONST) / allShares;\n\n\t\trewardPerShare += rpsIncrease;\n\t\trewardsReserve += rentReward;\n\t\tfacilityManagementFunds += facilityReward;\n\n\t\thousingToken.burn(ecosystemReward);\n\t\tISmartHousing(smartHousingAddr).addProjectRent(rentPayment.amount);\n\t}\n\n\t/// @notice Claims rent rewards for a given token.\n\t/// @return The updated HousingAttributes.\n\tfunction claimRentReward(\n\t\tuint256 nonce\n\t) external returns (HousingAttributes memory, rewardshares memory) {\n\t\taddress caller = msg.sender;\n\t\tuint256 currentRPS = rewardPerShare;\n\n\t\tHousingAttributes memory attr = projectSFT.getUserSFT(caller, nonce);\n\t\trewardshares memory rewardShares = computeRewardShares(attr);\n\t\tuint256 totalReward = rewardShares.total();\n\n\t\tif (totalReward == 0) {\n\t\t\t// Fail silently\n\t\t\treturn (attr, rewardShares);\n\t\t}\n\n\t\trequire(rewardsReserve >= totalReward, \"Computed rewards too large\");\n\n\t\trewardsReserve -= totalReward;\n\n\t\t// We use original owner since we are certain they are registered\n\t\t(, address referrer) = getReferrer(attr.originalOwner);\n\t\tif (rewardShares.referrerValue > 0) {\n\t\t\tif (referrer != address(0)) {\n\t\t\t\thousingToken.transfer(referrer, rewardShares.referrerValue); // Send to referrer\n\t\t\t} else {\n\t\t\t\thousingToken.burn(rewardShares.referrerValue); // Burn to add to ecosystem reward\n\t\t\t}\n\t\t}\n\n\t\tattr.rewardsPerShare = currentRPS;\n\n\t\tprojectSFT.update(\n\t\t\tcaller,\n\t\t\tnonce,\n\t\t\tprojectSFT.balanceOf(caller, nonce),\n\t\t\tabi.encode(attr)\n\t\t);\n\n\t\thousingToken.transfer(caller, rewardShares.userValue); // Send to user\n\n\t\treturn (attr, rewardShares);\n\t}\n\n\t/// @notice Computes the amount of rent claimable for a given token.\n\t/// @param attr The attributes of the token.\n\t/// @return The amount of rent claimable.\n\tfunction rentClaimable(\n\t\tHousingAttributes memory attr\n\t) public view returns (uint256) {\n\t\treturn computeRewardShares(attr).userValue;\n\t}\n\n\t/// @dev Computes the reward shares for a given token.\n\t/// @param attr The attributes of the token.\n\t/// @return The computed RewardShares.\n\tfunction computeRewardShares(\n\t\tHousingAttributes memory attr\n\t) internal view returns (rewardshares memory) {\n\t\tuint256 currentRPS = rewardPerShare;\n\n\t\tif (currentRPS == 0 || attr.rewardsPerShare >= currentRPS) {\n\t\t\treturn rewardshares({ userValue: 0, referrerValue: 0 });\n\t\t}\n\n\t\tuint256 reward = computeReward(attr, currentRPS);\n\n\t\treturn splitReward(reward);\n\t}\n}\n"
    },
    "contracts/housing-project/RewardSharing.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.24;\n\nimport \"./HousingSFT.sol\";\n\nuint256 constant DIVISION_SAFETY_CONST = 1_000_000_000_000_000_000;\n\nstruct rewardshares {\n\tuint256 userValue;\n\tuint256 referrerValue;\n}\n\nlibrary RewardShares {\n\tfunction total(rewardshares memory self) internal pure returns (uint256) {\n\t\treturn self.userValue + self.referrerValue;\n\t}\n}\n\nfunction splitReward(uint256 reward) pure returns (rewardshares memory) {\n\tuint256 referrerValue = (reward * 6_66) / 100_00; // would amount to approximately 5% of grand total\n\tuint256 userValue = reward - referrerValue;\n\n\treturn rewardshares(userValue, referrerValue);\n}\n\nfunction computeReward(\n\tHousingAttributes memory attr,\n\tuint256 contractRPS\n) pure returns (uint256) {\n\tif (contractRPS <= attr.rewardsPerShare) {\n\t\treturn 0;\n\t}\n\n\treturn\n\t\t((contractRPS - attr.rewardsPerShare) * attr.tokenWeight) /\n\t\tDIVISION_SAFETY_CONST;\n}\n"
    },
    "contracts/lib/EpochsAndPeriods.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// @title Epochs and Periods Management Library\n/// @notice This library provides functions to manage and calculate epochs and periods based on a genesis timestamp and an epoch length.\n/// @dev The epoch length is specified in hours, and the period is calculated as 30 epochs.\nlibrary EpochsAndPeriods {\n\tstruct Storage {\n\t\tuint256 genesis;\n\t\tuint256 epochLength;\n\t}\n\n\t/// @notice Initializes the storage with the current timestamp as the genesis and sets the epoch length.\n\t/// @param self The storage struct to initialize.\n\t/// @param _epochLength The length of an epoch in hours. This determines how long each epoch lasts.\n\t/// @dev This function should be called in the contract constructor to set the initial genesis timestamp and epoch length.\n\tfunction initialize(Storage storage self, uint256 _epochLength) internal {\n\t\tself.genesis = block.timestamp;\n\t\tself.epochLength = _epochLength;\n\t}\n\n\t/// @notice Returns the current epoch based on the genesis timestamp and epoch length.\n\t/// @param self The storage struct containing the genesis timestamp and epoch length.\n\t/// @return The current epoch number.\n\t/// @dev The epoch is calculated by dividing the time elapsed since genesis by the epoch length in seconds.\n\tfunction currentEpoch(\n\t\tStorage storage self\n\t) internal view returns (uint256) {\n\t\trequire(self.genesis > 0, \"Invalid genesis timestamp\");\n\t\treturn (block.timestamp - self.genesis) / (self.epochLength * 60 * 60);\n\t}\n\n\t/// @notice Returns the current period based on the current epoch.\n\t/// @param self The storage struct containing the genesis timestamp and epoch length.\n\t/// @return The current period number.\n\t/// @dev The period is calculated by dividing the current epoch by 30.\n\tfunction currentPeriod(\n\t\tStorage storage self\n\t) internal view returns (uint256) {\n\t\treturn currentEpoch(self) / 30;\n\t}\n}\n"
    },
    "contracts/lib/LkSHTAttributes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title LkSHTAttributes\n * @dev Library for handling attributes and unlocking of the Locked SmartHousing Token.\n */\nlibrary LkSHTAttributes {\n\tusing SafeMath for uint256;\n\n\t// TODO use this for mainnet uint256 constant LOCK_DURATION = 3 * 365 days; // 3 years\n\tuint256 constant LOCK_DURATION = 5 hours;\n\n\tstruct Attributes {\n\t\tuint256 initialAmount;\n\t\tuint256 amount;\n\t\tuint256 startTimestamp;\n\t\tuint256 endTimestamp;\n\t}\n\n\t/**\n\t * @dev Creates new attributes for a Locked SmartHousing Token.\n\t * @param startTimestamp The start time of the lock.\n\t * @param amount The amount of SmartHousing Tokens locked.\n\t * @return attributes The initialized attributes.\n\t */\n\tfunction newAttributes(\n\t\tuint256 startTimestamp,\n\t\tuint256 amount\n\t) internal pure returns (Attributes memory) {\n\t\treturn\n\t\t\tAttributes({\n\t\t\t\tinitialAmount: amount,\n\t\t\t\tamount: amount,\n\t\t\t\tstartTimestamp: startTimestamp,\n\t\t\t\tendTimestamp: startTimestamp.add(LOCK_DURATION)\n\t\t\t});\n\t}\n\n\t/**\n\t * @dev Calculates and deducts the unlocked amount based on the elapsed time.\n\t * @param self The attributes to update.\n\t * @return unlockedAmount The amount of tokens unlocked.\n\t */\n\tfunction unlockMatured(\n\t\tAttributes memory self\n\t)\n\t\tinternal\n\t\tview\n\t\treturns (uint256 unlockedAmount, Attributes memory newSelf)\n\t{\n\t\tuint256 elapsed = elapsedTime(self);\n\t\tunlockedAmount = self.amount.mul(elapsed).div(LOCK_DURATION);\n\n\t\tself.amount = self.amount.sub(unlockedAmount);\n\t\tnewSelf = self;\n\t}\n\n\t/**\n\t * @dev Calculates the elapsed time since the lock started.\n\t * @param self The attributes to use.\n\t * @return elapsedTime The elapsed time in seconds.\n\t */\n\tfunction elapsedTime(\n\t\tAttributes memory self\n\t) internal view returns (uint256) {\n\t\tuint256 currentTime = block.timestamp;\n\t\tif (currentTime >= self.endTimestamp) {\n\t\t\treturn LOCK_DURATION;\n\t\t} else {\n\t\t\treturn currentTime.sub(self.startTimestamp);\n\t\t}\n\t}\n}\n"
    },
    "contracts/lib/ProjectStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./TokenPayments.sol\";\n\nlibrary ProjectStorage {\n\tusing SafeMath for uint256;\n\tusing TokenPayments for TokenPayment;\n\tusing ProjectStorage for Data;\n\n\tenum Status {\n\t\tFundingPeriod,\n\t\tSuccessful,\n\t\tFailed\n\t}\n\n\tstruct Data {\n\t\tuint256 id; // Unique identifier for the project\n\t\taddress tokenAddress;\n\t\taddress projectAddress; // Address of the deployed HousingProject contract\n\t\tuint256 fundingGoal; // Target funding amount for the project\n\t\tuint256 fundingDeadline; // Deadline timestamp for the project funding\n\t\taddress fundingToken; // Address of the ERC20 token used for funding\n\t\tuint256 collectedFunds; // Amount of funds collected for the project\n\t}\n\n\tfunction status(Data storage self) internal view returns (Status) {\n\t\tif (self.collectedFunds >= self.fundingGoal) {\n\t\t\treturn Status.Successful;\n\t\t} else if (block.timestamp < self.fundingDeadline) {\n\t\t\treturn Status.FundingPeriod;\n\t\t} else {\n\t\t\treturn Status.Failed;\n\t\t}\n\t}\n\n\tfunction createNew(\n\t\tmapping(uint256 => Data) storage projects,\n\t\tmapping(address => uint256) storage projectsId,\n\t\tuint256 projectCount,\n\t\tuint256 fundingGoal,\n\t\tuint256 fundingDeadline,\n\t\taddress fundingToken,\n\t\taddress projectAddress,\n\t\taddress tokenAddress\n\t) internal returns (Data memory) {\n\t\trequire(fundingGoal > 0, \"Funding goal must be more than 0\");\n\t\trequire(\n\t\t\tfundingDeadline > block.timestamp,\n\t\t\t\"Deadline can't be in the past\"\n\t\t);\n\n\t\tuint256 newId = projectCount.add(1);\n\n\t\tData memory newProjectData = Data({\n\t\t\tid: newId,\n\t\t\tprojectAddress: projectAddress,\n\t\t\tfundingGoal: fundingGoal,\n\t\t\tfundingDeadline: fundingDeadline,\n\t\t\tfundingToken: fundingToken,\n\t\t\tcollectedFunds: 0,\n\t\t\ttokenAddress: tokenAddress\n\t\t});\n\n\t\tprojects[newId] = newProjectData;\n\t\tprojectsId[newProjectData.projectAddress] = newProjectData.id;\n\n\t\treturn newProjectData;\n\t}\n\n\tfunction fund(\n\t\tmapping(uint256 => Data) storage projects,\n\t\tmapping(address => uint256) storage usersDeposit,\n\t\tuint256 projectId,\n\t\taddress depositor,\n\t\tTokenPayment calldata payment\n\t) internal {\n\t\trequire(payment.amount > 0, \"Invalid funding amount\");\n\n\t\tData storage project = projects[projectId];\n\n\t\trequire(\n\t\t\tproject.status() == Status.FundingPeriod,\n\t\t\t\"Cannot fund project after deadline\"\n\t\t);\n\t\trequire(\n\t\t\taddress(payment.token) == project.fundingToken,\n\t\t\t\"Wrong token payment\"\n\t\t);\n\t\tpayment.receiveToken();\n\n\t\tproject.collectedFunds = project.collectedFunds.add(payment.amount);\n\t\tusersDeposit[depositor] = usersDeposit[depositor].add(payment.amount);\n\t}\n\n\t/**\n\t * @dev Retrieves and updates the user's deposit for a specific project.\n\t * @param projectId The ID of the project to retrieve the deposit for.\n\t * @param depositor The address of the depositor.\n\t * @return (ProjectStorage.Data, uint256) The project data and deposit amount.\n\t */\n\tfunction takeDeposit(\n\t\tmapping(uint256 => Data) storage projects,\n\t\tmapping(address => uint256) storage usersDeposit,\n\t\tuint256 projectId,\n\t\taddress depositor\n\t) internal returns (ProjectStorage.Data memory, uint256) {\n\t\tProjectStorage.Data storage project = projects[projectId];\n\t\trequire(project.id != 0, \"Invalid project ID\");\n\t\trequire(\n\t\t\tproject.status() == Status.Successful,\n\t\t\t\"Project not yet successful\"\n\t\t);\n\n\t\tuint256 depositAmount = usersDeposit[depositor];\n\t\trequire(depositAmount > 0, \"No deposit found\");\n\n\t\t// Update the deposit amount to zero\n\t\tusersDeposit[depositor] = 0;\n\n\t\treturn (project, depositAmount);\n\t}\n}\n"
    },
    "contracts/lib/TokenPayments.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { SFT } from \"../modules/SFT.sol\";\n\nstruct ERC20TokenPayment {\n\tIERC20 token;\n\tuint256 amount;\n}\n\nstruct TokenPayment {\n\taddress token;\n\tuint256 amount;\n\tuint256 nonce;\n}\n\nlibrary TokenPayments {\n\tfunction accept(ERC20TokenPayment calldata self) internal {\n\t\tTokenPayments.receiveERC20(self, msg.sender);\n\t}\n\n\tfunction receiveERC20(ERC20TokenPayment calldata payment) internal {\n\t\tTokenPayments.receiveERC20(payment, msg.sender);\n\t}\n\n\tfunction receiveERC20(\n\t\tERC20TokenPayment calldata payment,\n\t\taddress from\n\t) internal {\n\t\tpayment.token.transferFrom(from, address(this), payment.amount);\n\t}\n\n\t// Receives both Native, SFTs and ERC20; ERC20 have nonce as 0, Native coins have address 0 as token value\n\tfunction receiveToken(TokenPayment memory payment) internal {\n\t\treceiveToken(payment, msg.sender);\n\t}\n\n\tfunction receiveToken(TokenPayment memory payment, address from) internal {\n\t\tif (payment.token == address(0)) {\n\t\t\t// Native payment\n\n\t\t\trequire(\n\t\t\t\tpayment.amount == msg.value,\n\t\t\t\t\"expected payment amount must equal sent amount\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tfrom == msg.sender,\n\t\t\t\t\"can receive native payment only from caller\"\n\t\t\t);\n\t\t\t\n\t\t\t// Nothing to do again since the VM will handle balance movements\n\t\t} else if (payment.nonce == 0) {\n\t\t\tIERC20(payment.token).transferFrom(\n\t\t\t\tfrom,\n\t\t\t\taddress(this),\n\t\t\t\tpayment.amount\n\t\t\t);\n\t\t} else {\n\t\t\tSFT(payment.token).safeTransferFrom(\n\t\t\t\tfrom,\n\t\t\t\taddress(this),\n\t\t\t\tpayment.nonce,\n\t\t\t\tpayment.amount,\n\t\t\t\t\"\"\n\t\t\t);\n\t\t}\n\t}\n}\n"
    },
    "contracts/main/distribution/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../lib/EpochsAndPeriods.sol\";\nimport \"../../housing-project/HousingProject.sol\";\nimport \"../../modules/sht-module/Economics.sol\";\nimport { HstAttributes } from \"../HST.sol\";\n\nlibrary ProjectStakingRewards {\n\tusing SafeMath for uint256;\n\n\tstruct Value {\n\t\tuint256 toShare;\n\t\tuint256 checkpoint;\n\t}\n\n\tfunction add(Value storage self, uint256 rhs) internal {\n\t\tself.toShare = self.toShare.add(rhs);\n\t\tself.checkpoint = self.checkpoint.add(rhs);\n\t}\n\n\tfunction sub(Value storage self, uint256 rhs) internal {\n\t\tself.toShare = self.toShare.sub(rhs);\n\t}\n}\n\nlibrary Distribution {\n\tusing SafeMath for uint256;\n\tusing EpochsAndPeriods for EpochsAndPeriods.Storage;\n\tusing Entities for Entities.Value;\n\tusing ProjectStakingRewards for ProjectStakingRewards.Value;\n\n\tstruct Storage {\n\t\tuint256 totalFunds;\n\t\tuint256 genesisEpoch;\n\t\tuint256 projectsTotalReceivedRents;\n\t\tmapping(address => ProjectDistributionData) projectDets;\n\t\tuint256 lastFundsDispatchEpoch;\n\t\tuint256 shtTotalStakeWeight;\n\t\tuint256 shtRewardPerShare;\n\t\tuint256 shtStakingRewards;\n\t\tProjectStakingRewards.Value projectsStakingRewards;\n\t\tEntities.Value entityFunds;\n\t}\n\n\tstruct ProjectDistributionData {\n\t\tuint256 maxShares;\n\t\tuint256 receivedRents;\n\t}\n\n\t/// @notice Sets the total funds and the genesis epoch. This can only be done once.\n\t/// @param self The storage struct to set the total funds and genesis epoch.\n\t/// @param amount The amount of total funds to set.\n\t/// @param epochsAndPeriods The storage struct for epoch and period management.\n\tfunction setTotalFunds(\n\t\tStorage storage self,\n\t\tEpochsAndPeriods.Storage storage epochsAndPeriods,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(self.totalFunds == 0, \"Total funds already set\");\n\t\tself.totalFunds = amount;\n\t\tself.genesisEpoch = epochsAndPeriods.currentEpoch();\n\t}\n\n\t/// @notice Returns the total funds.\n\t/// @param self The storage struct containing the total funds.\n\t/// @return The total funds.\n\tfunction getTotalFunds(\n\t\tStorage storage self\n\t) internal view returns (uint256) {\n\t\treturn self.totalFunds;\n\t}\n\n\t/// @notice Returns the genesis epoch when the total funds were set.\n\t/// @param self The storage struct containing the genesis epoch.\n\t/// @return The genesis epoch.\n\tfunction getGenesisEpoch(\n\t\tStorage storage self\n\t) internal view returns (uint256) {\n\t\treturn self.genesisEpoch;\n\t}\n\n\t/// @notice Adds the rent received for a project and updates the total received rents and project-specific data.\n\t/// @dev This function updates the total amount of rent received across all projects and updates the specific project data.\n\t/// If the `maxShares` for the project has not been set, it retrieves and sets it from the `HousingProject` contract.\n\t/// @param self The storage struct for the `Distribution` contract where project and rent data is stored.\n\t/// @param projectAddress The address of the project whose rent is being added.\n\t/// @param amount The amount of rent received to be added to the project and total received rents.\n\tfunction addProjectRent(\n\t\tStorage storage self,\n\t\taddress projectAddress,\n\t\tuint256 amount\n\t) internal {\n\t\t// Update the total received rents across all projects\n\t\tself.projectsTotalReceivedRents += amount;\n\n\t\t// Retrieve or initialize project-specific data\n\t\tProjectDistributionData storage projectData = self.projectDets[\n\t\t\tprojectAddress\n\t\t];\n\n\t\t// If `maxShares` is not set, initialize it with the maximum supply from the HousingProject contract\n\t\tif (projectData.maxShares == 0) {\n\t\t\tprojectData.maxShares = HousingProject(projectAddress)\n\t\t\t\t.getMaxSupply();\n\t\t}\n\n\t\t// Add the received rent amount to the project's accumulated rents\n\t\tprojectData.receivedRents += amount;\n\t}\n\n\t/// @notice Generates rewards for the current epoch.\n\t/// @param self The storage struct for the `Distribution` contract.\n\tfunction generateRewards(\n\t\tStorage storage self,\n\t\tEpochsAndPeriods.Storage storage epochsAndPeriods\n\t) internal {\n\t\tuint256 currentEpoch = epochsAndPeriods.currentEpoch();\n\t\tif (currentEpoch <= self.lastFundsDispatchEpoch) {\n\t\t\treturn;\n\t\t}\n\n\t\tuint256 toDispatch = Emission.throughEpochRange(\n\t\t\tself.lastFundsDispatchEpoch,\n\t\t\tcurrentEpoch\n\t\t);\n\t\tEntities.Value memory entitiesValue = Entities.fromTotalValue(\n\t\t\ttoDispatch\n\t\t);\n\n\t\t// Take staking value\n\t\tuint256 stakingRewards = entitiesValue.staking;\n\t\tentitiesValue.staking = 0;\n\t\tself.entityFunds.add(entitiesValue);\n\n\t\tuint256 shtStakersShare = stakingRewards.mul(7).div(10); // 70% goes to SHT stakers\n\n\t\tuint256 totalShtWeight = self.shtTotalStakeWeight;\n\t\tif (totalShtWeight > 0) {\n\t\t\tuint256 rpsIncrease = shtStakersShare\n\t\t\t\t.mul(DIVISION_SAFETY_CONST)\n\t\t\t\t.div(totalShtWeight);\n\t\t\tself.shtRewardPerShare = self.shtRewardPerShare.add(rpsIncrease);\n\t\t}\n\n\t\tself.shtStakingRewards = self.shtStakingRewards.add(shtStakersShare);\n\t\tself.projectsStakingRewards.add(stakingRewards.sub(shtStakersShare));\n\n\t\tself.lastFundsDispatchEpoch = currentEpoch;\n\t}\n\n\t/// @notice Claims rewards for a given attribute.\n\t/// @param self The storage struct for the `Distribution` contract.\n\t/// @param attr The attributes struct for which rewards are being claimed.\n\t/// @return The total amount of rewards claimed.\n\tfunction claimRewards(\n\t\tStorage storage self,\n\t\tHstAttributes memory attr\n\t) internal returns (uint256, HstAttributes memory) {\n\t\tuint256 shtClaimed = 0;\n\n\t\t// Claim PT rewards\n\t\tuint256 ptRewardCheckpoint = self.projectsStakingRewards.checkpoint;\n\t\tif (ptRewardCheckpoint > 0) {\n\t\t\tfor (uint256 i = 0; i < attr.projectTokens.length; i++) {\n\t\t\t\tshtClaimed = shtClaimed.add(\n\t\t\t\t\tcomputeRewardForPT(\n\t\t\t\t\t\tself,\n\t\t\t\t\t\tattr.projectTokens[i],\n\t\t\t\t\t\tattr.projectsShareCheckpoint,\n\t\t\t\t\t\tptRewardCheckpoint\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (self.projectsStakingRewards.toShare < shtClaimed) {\n\t\t\t\tshtClaimed = self.projectsStakingRewards.toShare;\n\t\t\t}\n\t\t\tself.projectsStakingRewards.toShare = self\n\t\t\t\t.projectsStakingRewards\n\t\t\t\t.toShare\n\t\t\t\t.sub(shtClaimed);\n\t\t}\n\n\t\t// Claim SHT rewards\n\t\tuint256 shtRPS = self.shtRewardPerShare;\n\t\tif (shtRPS > 0 && attr.shtRewardPerShare < shtRPS) {\n\t\t\tuint256 shtReward = (shtRPS.sub(attr.shtRewardPerShare))\n\t\t\t\t.mul(attr.stakeWeight)\n\t\t\t\t.div(DIVISION_SAFETY_CONST);\n\t\t\tif (self.shtStakingRewards < shtReward) {\n\t\t\t\tshtClaimed = self.shtStakingRewards;\n\t\t\t}\n\t\t\tself.shtStakingRewards = self.shtStakingRewards.sub(shtReward);\n\n\t\t\tshtClaimed = shtClaimed.add(shtReward);\n\t\t}\n\n\t\t// Update claim parameters\n\t\tattr.shtRewardPerShare = shtRPS;\n\t\tattr.projectsShareCheckpoint = ptRewardCheckpoint;\n\n\t\treturn (shtClaimed, attr);\n\t}\n\n\t/// @notice Computes the reward for a given PT (Housing Project Token).\n\t/// @param self The storage struct for the `Distribution` contract.\n\t/// @param tokenPayment The token payment of the housing project.\n\t/// @param stakingCheckPoint The previous checkpoint value.\n\t/// @param tokenCheckPoint The new checkpoint value.\n\t/// @return reward The computed reward for the given PT.\n\tfunction computeRewardForPT(\n\t\tStorage storage self,\n\t\tTokenPayment memory tokenPayment,\n\t\tuint256 stakingCheckPoint,\n\t\tuint256 tokenCheckPoint\n\t) internal view returns (uint256 reward) {\n\t\tif (stakingCheckPoint >= tokenCheckPoint) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tProjectDistributionData storage projectData = self.projectDets[\n\t\t\ttokenPayment.token\n\t\t];\n\t\trequire(\n\t\t\ttokenPayment.amount <= projectData.maxShares,\n\t\t\t\"Project token amount too large\"\n\t\t);\n\n\t\tuint256 shareIncrease = tokenCheckPoint.sub(stakingCheckPoint);\n\t\t// Project's allocation is dynamic, as rents received chages\n\t\tuint256 projectAllocation = shareIncrease\n\t\t\t.mul(projectData.receivedRents)\n\t\t\t.div(self.projectsTotalReceivedRents);\n\n\t\treward = projectAllocation.mul(tokenPayment.amount).div(\n\t\t\tprojectData.maxShares\n\t\t);\n\t}\n\n\t/// @notice Enters staking for the given attributes.\n\t/// @param self The storage struct for the `Distribution` contract.\n\t/// @param stakeWeight The stake weight to be added.\n\tfunction enterStaking(Storage storage self, uint256 stakeWeight) internal {\n\t\tself.shtTotalStakeWeight = self.shtTotalStakeWeight.add(stakeWeight);\n\t}\n}\n"
    },
    "contracts/main/HST.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport { TokenPayment } from \"../lib/TokenPayments.sol\";\nimport { SFT } from \"../modules/SFT.sol\";\n\nlibrary NewHousingStakingToken {\n\tfunction create() external returns (HousingStakingToken) {\n\t\treturn new HousingStakingToken();\n\t}\n}\n\nstruct HstAttributes {\n\tTokenPayment[] projectTokens;\n\tuint256 projectsShareCheckpoint;\n\tuint256 shtRewardPerShare;\n\tuint256 shtAmount;\n\tuint256 stakeWeight;\n\tuint256 lkDuration;\n\tuint256 lkShtNonce;\n}\n\ncontract HousingStakingToken is SFT {\n\tusing SafeMath for uint256;\n\n\tuint256 public constant MIN_EPOCHS_LOCK = 180;\n\tuint256 public constant MAX_EPOCHS_LOCK = 1080;\n\n\tevent MintHstToken(\n\t\taddress indexed to,\n\t\tuint256 nonce,\n\t\tHstAttributes attributes\n\t);\n\n\tconstructor() SFT(\"Housing Staking Token\", \"HST\") {}\n\n\tfunction mint(\n\t\tTokenPayment[] calldata projectTokens,\n\t\tuint256 projectsShareCheckpoint,\n\t\tuint256 shtRewardPerShare,\n\t\tuint256 lkDuration,\n\t\tuint256 shtAmount,\n\t\tuint256 lkShtNonce\n\t) external onlyOwner returns (HstAttributes memory attr) {\n\t\taddress caller = msg.sender;\n\n\t\t// Validate lock duration\n\t\trequire(\n\t\t\tlkDuration >= MIN_EPOCHS_LOCK && lkDuration <= MAX_EPOCHS_LOCK,\n\t\t\t\"Invalid lock duration\"\n\t\t);\n\n\t\trequire(shtAmount > 0 || lkShtNonce > 0, \"Must send SHT\");\n\t\tuint256 projectTokenCount = projectTokens.length;\n\t\trequire(\n\t\t\tprojectTokenCount > 0 && projectTokenCount <= 10,\n\t\t\t\"Must send project tokens of approved number\"\n\t\t);\n\n\t\tuint256 stakeWeight = shtAmount.mul(lkDuration);\n\t\tattr = HstAttributes({\n\t\t\tprojectTokens: projectTokens,\n\t\t\tprojectsShareCheckpoint: projectsShareCheckpoint,\n\t\t\tshtRewardPerShare: shtRewardPerShare,\n\t\t\tshtAmount: shtAmount,\n\t\t\tstakeWeight: stakeWeight,\n\t\t\tlkDuration: lkDuration,\n\t\t\tlkShtNonce: lkShtNonce\n\t\t});\n\n\t\t// Mint the HST token\n\t\tuint256 nonce = _mint(caller, 1, abi.encode(attr), \"\");\n\n\t\temit MintHstToken(caller, nonce, attr);\n\t}\n}\n"
    },
    "contracts/main/Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"../lib/TokenPayments.sol\";\n\ninterface ISmartHousing {\n\tfunction addProjectRent(uint256 amount) external;\n\n\tfunction createRefIDViaProxy(\n\t\taddress userAddr,\n\t\tuint256 referrerId\n\t) external returns (uint256);\n\n\tfunction addProject(address projectAddress) external;\n\n\tfunction setUpSHT(ERC20TokenPayment calldata payment) external;\n}\n\ninterface IUserModule {\n\tfunction getReferrer(address user) external view returns (uint, address);\n}\n"
    },
    "contracts/main/SmartHousing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"../lib/TokenPayments.sol\";\nimport \"../modules/sht-module/SHT.sol\";\nimport \"../project-funding/ProjectFunding.sol\";\n\nimport \"./Interface.sol\";\nimport \"./User.sol\";\n\nimport { Distribution } from \"./distribution/Storage.sol\";\nimport { EpochsAndPeriods } from \"../lib/EpochsAndPeriods.sol\";\nimport { HousingStakingToken, NewHousingStakingToken, HstAttributes } from \"./HST.sol\";\n\nimport { HousingProject } from \"../housing-project/HousingProject.sol\";\nimport { rewardshares } from \"../housing-project/RewardSharing.sol\";\n\n/// @title SmartHousing\n/// @notice SmartHousing leverages blockchain technology to revolutionize real estate investment and development by enabling the tokenization of properties.\n/// @dev This contract allows for fractional ownership and ease of investment.\n/// This innovative approach addresses the high costs and limited access to real estate investments in Abuja, Nigeria, making the market more inclusive and accessible.\n/// By selling tokens, SmartHousing provides developers with immediate access to liquid funds, ensuring the timely and quality completion of affordable development projects.\n/// The SmartHousing Contract is the main contract for the SmartHousing ecosystem.\n/// This contract owns and deploys HousingProject contracts, which will represent the properties owned and managed by the SmartHousing project.\n/// The management of ecosystem users will also be done in this contract.\ncontract SmartHousing is\n\tISmartHousing,\n\tOwnable,\n\tUserModule,\n\tHousingStakingToken\n{\n\tusing TokenPayments for ERC20TokenPayment;\n\tusing Distribution for Distribution.Storage;\n\tusing EpochsAndPeriods for EpochsAndPeriods.Storage;\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing TokenPayments for TokenPayment;\n\tusing SafeMath for uint256;\n\n\taddress public projectFundingAddress;\n\taddress public coinbaseAddress;\n\taddress public shtTokenAddress;\n\tHousingStakingToken public hst;\n\n\tDistribution.Storage public distributionStorage;\n\tEpochsAndPeriods.Storage public epochsAndPeriodsStorage;\n\n\tenum Permissions {\n\t\tNONE,\n\t\tHOUSING_PROJECT\n\t}\n\n\tmapping(address => Permissions) public permissions;\n\tEnumerableSet.AddressSet private _projectsToken; // Enumerable list of project addresses\n\n\tconstructor(address conibase, address projectFunding) {\n\t\tcoinbaseAddress = conibase;\n\t\tprojectFundingAddress = projectFunding;\n\t\thst = NewHousingStakingToken.create();\n\n\t\t// TODO use this for mainnet epochsAndPeriodsStorage.initialize(24); // One epoch will span 24 hours\n\t\tepochsAndPeriodsStorage.initialize(1); // One epoch will span 1 hour\n\t}\n\n\t/// @notice Register a new user via proxy or get the referral ID if already registered.\n\t/// @param userAddr The address of the user.\n\t/// @param referrerId The ID of the referrer.\n\t/// @return The ID of the registered user.\n\tfunction createRefIDViaProxy(\n\t\taddress userAddr,\n\t\tuint256 referrerId\n\t) external onlyProjectFunding returns (uint256) {\n\t\treturn _createOrGetUserId(userAddr, referrerId);\n\t}\n\n\tfunction setUpSHT(ERC20TokenPayment calldata payment) external {\n\t\trequire(\n\t\t\tmsg.sender == coinbaseAddress,\n\t\t\t\"Caller is not the coinbase address\"\n\t\t);\n\n\t\t// Ensure that the SHT token has not been set already\n\t\trequire(shtTokenAddress == address(0), \"SHT token already set\");\n\t\tshtTokenAddress = address(payment.token);\n\n\t\t// Verify that the correct amount of SHT has been sent\n\t\trequire(\n\t\t\tpayment.amount == SHT.ECOSYSTEM_DISTRIBUTION_FUNDS,\n\t\t\t\"Must send all ecosystem funds\"\n\t\t);\n\t\tpayment.accept();\n\n\t\t// Set the total funds in distribution storage\n\t\tdistributionStorage.setTotalFunds(\n\t\t\tepochsAndPeriodsStorage,\n\t\t\tpayment.amount\n\t\t);\n\t}\n\n\t/// @notice Adds a new project and sets its permissions.\n\t/// @param projectAddress The address of the new project.\n\tfunction addProject(address projectAddress) external onlyProjectFunding {\n\t\t_setPermissions(projectAddress, Permissions.HOUSING_PROJECT);\n\t\t_projectsToken.add(projectAddress); // Register the project address\n\t}\n\n\t/// @notice Adds rent to a project and updates the distribution storage.\n\t/// @dev projectAddress is the msg.msg.sender which must be a recognised HousingProject contract\n\t/// @param amount The amount of rent received.\n\tfunction addProjectRent(uint256 amount) external onlyHousingProject {\n\t\taddress projectAddress = msg.sender;\n\t\tdistributionStorage.addProjectRent(projectAddress, amount);\n\t}\n\n\tfunction stake(\n\t\tTokenPayment[] calldata stakingTokens,\n\t\tuint256 epochsLock,\n\t\tuint256 referrerId\n\t) external payable {\n\t\trequire(\n\t\t\tepochsLock >= MIN_EPOCHS_LOCK && epochsLock <= MAX_EPOCHS_LOCK,\n\t\t\t\"Invalid epochs lock period\"\n\t\t);\n\n\t\taddress caller = msg.sender;\n\n\t\t// Try create ID\n\t\t_createOrGetUserId(caller, referrerId);\n\n\t\t// Generate rewards before staking\n\t\tdistributionStorage.generateRewards(epochsAndPeriodsStorage);\n\n\t\tHstAttributes memory newAttr = _mintHstToken(\n\t\t\tstakingTokens,\n\t\t\tdistributionStorage.projectsStakingRewards.checkpoint,\n\t\t\tdistributionStorage.shtRewardPerShare,\n\t\t\tepochsLock,\n\t\t\tshtTokenAddress,\n\t\t\taddress(ProjectFunding(projectFundingAddress).lkSht())\n\t\t);\n\n\t\tdistributionStorage.enterStaking(newAttr.stakeWeight);\n\t}\n\n\tfunction claimRewards(uint256 hstTokenId, uint256 referrerId) external {\n\t\taddress caller = msg.sender;\n\t\t_createOrGetUserId(caller, referrerId);\n\n\t\tuint256 callerHstBal = hst.balanceOf(caller, hstTokenId);\n\n\t\trequire(callerHstBal > 0, \"Caller does not own the hst token\");\n\n\t\tdistributionStorage.generateRewards(epochsAndPeriodsStorage);\n\n\t\t(uint256 claimedSHT, HstAttributes memory hstAttr) = distributionStorage\n\t\t\t.claimRewards(\n\t\t\t\tabi.decode(getRawTokenAttributes(hstTokenId), (HstAttributes))\n\t\t\t);\n\t\tuint256 rentRewards = 0;\n\n\t\t// Claim rent rewards from HousingProjects\n\t\tfor (uint256 i = 0; i < hstAttr.projectTokens.length; i++) {\n\t\t\tTokenPayment memory projectToken = hstAttr.projectTokens[i];\n\t\t\trequire(\n\t\t\t\tprojectToken.token != address(0),\n\t\t\t\t\"Invalid project address\"\n\t\t\t);\n\n\t\t\t// Call the external contract's claimRentReward function\n\t\t\t(, rewardshares memory rewardShares) = HousingProject(\n\t\t\t\tprojectToken.token\n\t\t\t).claimRentReward(projectToken.nonce);\n\n\t\t\trentRewards = rentRewards.add(rewardShares.userValue);\n\t\t}\n\n\t\t// Update the attributes in the hst token\n\t\thst.update(caller, hstTokenId, callerHstBal, abi.encode(hstAttr));\n\n\t\tERC20Burnable shtToken = ERC20Burnable(shtTokenAddress);\n\n\t\tif (claimedSHT > 0) {\n\t\t\tuint256 referrerValue = claimedSHT.mul(25).div(1000);\n\t\t\tclaimedSHT = claimedSHT.sub(referrerValue);\n\n\t\t\t// Do referrer operations\n\t\t\t(, address referrerAddr) = getReferrer(caller);\n\t\t\tif (referrerAddr != address(0)) {\n\t\t\t\tshtToken.transfer(referrerAddr, referrerValue);\n\t\t\t} else {\n\t\t\t\tshtToken.burn(referrerValue);\n\t\t\t}\n\t\t}\n\n\t\tshtToken.transfer(caller, claimedSHT.add(rentRewards));\n\t}\n\n\tfunction projectDets(\n\t\taddress project\n\t) public view returns (Distribution.ProjectDistributionData memory) {\n\t\treturn distributionStorage.projectDets[project];\n\t}\n\n\tfunction projectsToken() public view returns (address[] memory) {\n\t\treturn _projectsToken.values();\n\t}\n\n\t/// @notice Sets the permissions for a given address.\n\t/// @param addr The address to set permissions for.\n\t/// @param perm The permissions to set.\n\tfunction _setPermissions(address addr, Permissions perm) internal {\n\t\tpermissions[addr] = perm;\n\t}\n\n\tfunction _mintHstToken(\n\t\tTokenPayment[] calldata payments,\n\t\tuint256 projectsShareCheckpoint,\n\t\tuint256 shtRewardPerShare,\n\t\tuint256 lkDuration,\n\t\taddress shtAddress,\n\t\taddress lkShtAddress\n\t) internal returns (HstAttributes memory attr) {\n\t\taddress caller = msg.sender;\n\n\t\tuint256 maxProjectTokens = 10;\n\t\tTokenPayment[] memory projectTokens = new TokenPayment[](\n\t\t\tmaxProjectTokens\n\t\t);\n\t\tuint256 projectTokenCount = 0;\n\t\tuint256 shtAmount = 0;\n\t\tuint256 lkShtNonce = 0;\n\n\t\tfor (uint256 i = 0; i < payments.length; i++) {\n\t\t\tTokenPayment memory payment = payments[i];\n\n\t\t\tif (payment.token == shtAddress) {\n\t\t\t\tshtAmount = payment.amount;\n\t\t\t} else if (payment.token == lkShtAddress) {\n\t\t\t\tlkShtNonce = payment.nonce;\n\t\t\t} else if (_projectsToken.contains(payment.token)) {\n\t\t\t\t// Validate that the payment is for an allowed project token\n\t\t\t\trequire(\n\t\t\t\t\tprojectTokens.length < maxProjectTokens,\n\t\t\t\t\t\"Max project tokens exceeded\"\n\t\t\t\t);\n\n\t\t\t\tprojectTokens[projectTokenCount] = payment;\n\t\t\t\tprojectTokenCount++;\n\t\t\t} else {\n\t\t\t\trevert(\"Invalid Sent Token\");\n\t\t\t}\n\n\t\t\tpayment.receiveToken(caller);\n\t\t}\n\n\t\treturn\n\t\t\thst.mint(\n\t\t\t\tprojectTokens,\n\t\t\t\tprojectsShareCheckpoint,\n\t\t\t\tshtRewardPerShare,\n\t\t\t\tlkDuration,\n\t\t\t\tshtAmount,\n\t\t\t\tlkShtNonce\n\t\t\t);\n\t}\n\n\tmodifier onlyProjectFunding() {\n\t\trequire(\n\t\t\tmsg.sender == projectFundingAddress,\n\t\t\t\"Caller is not the project funder\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyHousingProject() {\n\t\trequire(\n\t\t\tpermissions[msg.sender] == Permissions.HOUSING_PROJECT,\n\t\t\t\"Caller is not an accepted housing project\"\n\t\t);\n\t\t_;\n\t}\n}\n"
    },
    "contracts/main/User.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.24;\n\nimport \"./Interface.sol\";\n\nabstract contract UserModule is IUserModule {\n\tstruct ReferralInfo {\n\t\tuint256 id;\n\t\taddress referralAddress;\n\t}\n\n\tstruct User {\n\t\tuint256 id;\n\t\taddress addr;\n\t\tuint256 referrerId;\n\t\tuint256[] referrals;\n\t}\n\n\tuint256 public userCount;\n\tmapping(address => User) public users;\n\tmapping(uint256 => address) public userIdToAddress;\n\n\tevent UserRegistered(\n\t\tuint256 userId,\n\t\taddress userAddress,\n\t\tuint256 referrerId\n\t);\n\tevent ReferralAdded(uint256 referrerId, uint256 referralId);\n\n\t/// @notice Register a new user or get the referral ID if already registered.\n\t/// @param referrerId The ID of the referrer.\n\t/// @return The ID of the registered user.\n\tfunction createRefID(uint256 referrerId) external returns (uint256) {\n\t\taddress userAddr = msg.sender;\n\t\treturn _createOrGetUserId(userAddr, referrerId);\n\t}\n\n\t/// @notice Gets the referrer and referrer ID of a user.\n\t/// @param userAddress The address of the user.\n\t/// @return referrerId The ID of the referrer, 0 if none.\n\t/// @return referrerAddress The address of the referrer, address(0) if none.\n\tfunction getReferrer(\n\t\taddress userAddress\n\t) public view returns (uint256 referrerId, address referrerAddress) {\n\t\tUser storage user = users[userAddress];\n\t\treferrerId = user.referrerId;\n\t\treferrerAddress = userIdToAddress[referrerId];\n\t}\n\n\tfunction getUserId(\n\t\taddress userAddress\n\t) external view returns (uint256 userId) {\n\t\treturn users[userAddress].id;\n\t}\n\n\tfunction getReferrals(\n\t\taddress userAddress\n\t) external view returns (ReferralInfo[] memory) {\n\t\tuint256[] memory referralIds = users[userAddress].referrals;\n\t\tReferralInfo[] memory referrals = new ReferralInfo[](\n\t\t\treferralIds.length\n\t\t);\n\n\t\tfor (uint256 i = 0; i < referralIds.length; i++) {\n\t\t\tuint256 id = referralIds[i];\n\t\t\taddress refAddr = userIdToAddress[id];\n\t\t\treferrals[i] = ReferralInfo({ id: id, referralAddress: refAddr });\n\t\t}\n\n\t\treturn referrals;\n\t}\n\n\t/// @notice Internal function to create or get the user ID.\n\t/// @param userAddr The address of the user.\n\t/// @param referrerId The ID of the referrer.\n\t/// @return The ID of the user.\n\tfunction _createOrGetUserId(\n\t\taddress userAddr,\n\t\tuint256 referrerId\n\t) internal returns (uint256) {\n\t\tif (users[userAddr].id != 0) {\n\t\t\treturn users[userAddr].id;\n\t\t}\n\n\t\tuserCount++;\n\t\tusers[userAddr] = User({\n\t\t\tid: userCount,\n\t\t\taddr: userAddr,\n\t\t\treferrerId: referrerId,\n\t\t\treferrals: new uint256[](0)\n\t\t});\n\t\tuserIdToAddress[userCount] = userAddr;\n\n\t\tif (\n\t\t\treferrerId != 0 &&\n\t\t\treferrerId != userCount &&\n\t\t\tuserIdToAddress[referrerId] != address(0)\n\t\t) {\n\t\t\tusers[userIdToAddress[referrerId]].referrals.push(userCount);\n\t\t\temit ReferralAdded(referrerId, userCount);\n\t\t}\n\n\t\temit UserRegistered(userCount, userAddr, referrerId);\n\t\treturn userCount;\n\t}\n}\n"
    },
    "contracts/modules/LockedSmartHousingToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../lib/LkSHTAttributes.sol\";\nimport \"../lib/TokenPayments.sol\";\nimport \"../modules/SFT.sol\";\n\nlibrary NewLkSHT {\n\tfunction create() external returns (LkSHT) {\n\t\treturn new LkSHT(\"Locked Housing Token\", \"LkSHT\");\n\t}\n}\n\n/**\n * @title LockedSmartHousingToken\n * @dev SFT token that locks SmartHousing Tokens (SHT) during ICO.\n * Allows transfers only to whitelisted addresses.\n */\ncontract LkSHT is SFT {\n\tusing SafeMath for uint256;\n\tusing TokenPayments for ERC20TokenPayment;\n\n\tstruct LkSHTBalance {\n\t\tuint256 nonce;\n\t\tuint256 amount;\n\t\tLkSHTAttributes.Attributes attributes;\n\t}\n\n\tuint256 immutable startTimestamp = block.timestamp;\n\n\tconstructor(\n\t\tstring memory name_,\n\t\tstring memory symbol_\n\t) SFT(name_, symbol_) {}\n\n\tevent TokensMinted(address indexed to, uint256 amount);\n\n\tfunction sftBalance(\n\t\taddress user\n\t) public view returns (LkSHTBalance[] memory) {\n\t\tSftBalance[] memory _sftBals = _sftBalance(user);\n\t\tLkSHTBalance[] memory balance = new LkSHTBalance[](_sftBals.length);\n\n\t\tfor (uint256 i; i < _sftBals.length; i++) {\n\t\t\tSftBalance memory _sftBal = _sftBals[i];\n\n\t\t\tbalance[i] = LkSHTBalance({\n\t\t\t\tnonce: _sftBal.nonce,\n\t\t\t\tamount: _sftBal.amount,\n\t\t\t\tattributes: abi.decode(\n\t\t\t\t\t_sftBal.attributes,\n\t\t\t\t\t(LkSHTAttributes.Attributes)\n\t\t\t\t)\n\t\t\t});\n\t\t}\n\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @dev Mints new Locked SmartHousing Tokens (LkSHT) by locking SHT.\n\t * @param amount The amount of SHT to lock.\n\t * @param to The address to mint the tokens to.\n\t */\n\tfunction mint(uint256 amount, address to) external onlyOwner {\n\t\tbytes memory attributes = abi.encode(\n\t\t\tLkSHTAttributes.newAttributes(startTimestamp, amount)\n\t\t);\n\n\t\tsuper._mint(to, amount, attributes, \"LockedSmartHousingToken\");\n\n\t\temit TokensMinted(to, amount);\n\t}\n}\n"
    },
    "contracts/modules/SFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// TODO I think we should create a standard of this\nabstract contract SFT is ERC1155, Ownable {\n\tusing Counters for Counters.Counter;\n\tusing EnumerableSet for EnumerableSet.UintSet;\n\n\tstruct SftBalance {\n\t\tuint256 nonce;\n\t\tuint256 amount;\n\t\tbytes attributes;\n\t}\n\n\tCounters.Counter private _nonceCounter;\n\tstring private _name;\n\tstring private _symbol;\n\n\t// Mapping from nonce to token attributes as bytes\n\tmapping(uint256 => bytes) private _tokenAttributes;\n\n\t// Mapping from address to list of owned token nonces\n\tmapping(address => EnumerableSet.UintSet) private _addressToNonces;\n\n\tconstructor(string memory name_, string memory symbol_) ERC1155(\"\") {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t}\n\n\t// Private function to mint new tokens\n\tfunction _mint(\n\t\taddress to,\n\t\tuint256 amount,\n\t\tbytes memory attributes,\n\t\tbytes memory data\n\t) internal returns (uint256) {\n\t\t_nonceCounter.increment();\n\t\tuint256 nonce = _nonceCounter.current();\n\n\t\t// Store the attributes\n\t\t_tokenAttributes[nonce] = attributes;\n\n\t\t// Mint the token with the nonce as its ID\n\t\tsuper._mint(to, nonce, amount, data);\n\n\t\t// Track the nonce for the address\n\t\t_addressToNonces[to].add(nonce);\n\n\t\treturn nonce;\n\t}\n\n\tfunction name() public view returns (string memory) {\n\t\treturn _name;\n\t}\n\n\tfunction symbol() public view returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\tfunction tokenInfo() public view returns (string memory, string memory) {\n\t\treturn (_name, _symbol);\n\t}\n\n\t// Function to get token attributes by nonce\n\tfunction getRawTokenAttributes(\n\t\tuint256 nonce\n\t) public view returns (bytes memory) {\n\t\treturn _tokenAttributes[nonce];\n\t}\n\n\t// Function to get list of nonces owned by an address\n\tfunction getNonces(address owner) public view returns (uint256[] memory) {\n\t\treturn _addressToNonces[owner].values();\n\t}\n\n\tfunction hasSFT(address owner, uint256 nonce) public view returns (bool) {\n\t\treturn _addressToNonces[owner].contains(nonce);\n\t}\n\n\t/// Burns all the NFT balance of user at nonce, creates new with balance and attributes\n\tfunction update(\n\t\taddress user,\n\t\tuint256 nonce,\n\t\tuint256 amount,\n\t\tbytes memory attr\n\t) external onlyOwner {\n\t\t_burn(user, nonce, amount);\n\t\t_mint(user, amount, attr, \"\");\n\t}\n\n\tfunction _sftBalance(\n\t\taddress user\n\t) internal view returns (SftBalance[] memory) {\n\t\tuint256[] memory nonces = getNonces(user);\n\t\tSftBalance[] memory balance = new SftBalance[](nonces.length);\n\n\t\tfor (uint256 i; i < nonces.length; i++) {\n\t\t\tuint256 nonce = nonces[i];\n\t\t\tbytes memory attributes = _tokenAttributes[nonce];\n\t\t\tuint256 amount = balanceOf(user, nonce);\n\n\t\t\tbalance[i] = SftBalance({\n\t\t\t\tnonce: nonce,\n\t\t\t\tamount: amount,\n\t\t\t\tattributes: attributes\n\t\t\t});\n\t\t}\n\n\t\treturn balance;\n\t}\n\n\t// Override _beforeTokenTransfer to handle address-to-nonce mapping\n\tfunction _beforeTokenTransfer(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256[] memory ids,\n\t\tuint256[] memory amounts,\n\t\tbytes memory data\n\t) internal virtual override {\n\t\tsuper._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n\t\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\t\t_addressToNonces[from].remove(ids[i]);\n\t\t}\n\n\t\tfor (uint256 i = 0; i < ids.length; i++) {\n\t\t\t_addressToNonces[to].add(ids[i]);\n\t\t}\n\t}\n}\n"
    },
    "contracts/modules/sht-module/Economics.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\nlibrary Emission {\n\tusing PRBMathUD60x18 for uint256;\n\n\tuint256 private constant DECAY_RATE = 9998e14; // 0.9998 with 18 decimals\n\tuint256 private constant E0 = 2729727036845720116116; // Example initial emission\n\n\tfunction atEpoch(uint256 epoch) internal pure returns (uint256) {\n\t\tuint256 decayFactor = PRBMathUD60x18.pow(DECAY_RATE, epoch);\n\t\treturn E0.mul(decayFactor) / 1e18;\n\t}\n\n\t/// @notice Computes E0 * (0.9998^epochStart  0.9998^epochEnd)\n\t/// @param epochStart the starting epoch\n\t/// @param epochEnd the end epoch\n\tfunction throughEpochRange(\n\t\tuint256 epochStart,\n\t\tuint256 epochEnd\n\t) internal pure returns (uint256) {\n\t\trequire(epochEnd > epochStart, \"Invalid epoch range\");\n\n\t\tuint256 startFactor = PRBMathUD60x18.pow(DECAY_RATE, epochStart);\n\t\tuint256 endFactor = PRBMathUD60x18.pow(DECAY_RATE, epochEnd);\n\n\t\tuint256 totalEmission = E0\n\t\t\t.mul(SafeMath.sub(startFactor, endFactor))\n\t\t\t.div(DECAY_RATE.ln());\n\t\treturn totalEmission;\n\t}\n}\n\nlibrary Entities {\n\tusing SafeMath for uint256;\n\n\tuint32 public constant UNITY = 100_00;\n\n\tuint32 public constant TEAM_AND_ADVISORS_RATIO = 23_05;\n\tuint32 public constant PROTOCOL_DEVELOPMENT_RATIO = 30_05;\n\tuint32 public constant GROWTH_RATIO = 15_35;\n\tuint32 public constant STAKING_RATIO = 16_55;\n\tuint32 public constant PROJECTS_RESERVE_RATIO = 8_00;\n\tuint32 public constant LP_AND_LISTINGS_RATIO = 7_00;\n\n\tstruct Value {\n\t\tuint256 team;\n\t\tuint256 protocol;\n\t\tuint256 growth;\n\t\tuint256 staking;\n\t\tuint256 projectsReserve;\n\t\tuint256 lpAndListing;\n\t}\n\n\tfunction fromTotalValue(\n\t\tuint256 totalValue\n\t) internal pure returns (Value memory) {\n\t\tuint256 othersTotal = totalValue\n\t\t\t.mul(UNITY - PROTOCOL_DEVELOPMENT_RATIO)\n\t\t\t.div(UNITY);\n\n\t\tuint256 team = othersTotal.mul(TEAM_AND_ADVISORS_RATIO).div(UNITY);\n\t\tuint256 growth = othersTotal.mul(GROWTH_RATIO).div(UNITY);\n\t\tuint256 staking = othersTotal.mul(STAKING_RATIO).div(UNITY);\n\t\tuint256 projectsReserve = othersTotal.mul(PROJECTS_RESERVE_RATIO).div(\n\t\t\tUNITY\n\t\t);\n\t\tuint256 lpAndListing = othersTotal.mul(LP_AND_LISTINGS_RATIO).div(\n\t\t\tUNITY\n\t\t);\n\n\t\tuint256 protocol = totalValue\n\t\t\t.sub(team)\n\t\t\t.sub(growth)\n\t\t\t.sub(staking)\n\t\t\t.sub(projectsReserve)\n\t\t\t.sub(lpAndListing);\n\n\t\treturn\n\t\t\tValue({\n\t\t\t\tteam: team,\n\t\t\t\tprotocol: protocol,\n\t\t\t\tgrowth: growth,\n\t\t\t\tstaking: staking,\n\t\t\t\tprojectsReserve: projectsReserve,\n\t\t\t\tlpAndListing: lpAndListing\n\t\t\t});\n\t}\n\n\tfunction total(Value memory value) internal pure returns (uint256) {\n\t\treturn\n\t\t\tvalue\n\t\t\t\t.team\n\t\t\t\t.add(value.protocol)\n\t\t\t\t.add(value.growth)\n\t\t\t\t.add(value.staking)\n\t\t\t\t.add(value.projectsReserve)\n\t\t\t\t.add(value.lpAndListing);\n\t}\n\n\tfunction add(Value storage self, Value memory rhs) internal {\n\t\tself.team = self.team.add(rhs.team);\n\t\tself.protocol = self.protocol.add(rhs.protocol);\n\t\tself.growth = self.growth.add(rhs.growth);\n\t\tself.staking = self.staking.add(rhs.staking);\n\t\tself.projectsReserve = self.projectsReserve.add(rhs.projectsReserve);\n\t\tself.lpAndListing = self.lpAndListing.add(rhs.lpAndListing);\n\t}\n}\n"
    },
    "contracts/modules/sht-module/SHT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nlibrary SHT {\n\tuint256 public constant DECIMALS = 18;\n\tuint256 public constant ONE = 10 ** DECIMALS;\n\tuint256 public constant MAX_SUPPLY = 21_000_000 * ONE;\n\tuint256 public constant ECOSYSTEM_DISTRIBUTION_FUNDS =\n\t\t(13_650_000 * ONE) + 2_248_573_618_499_339;\n\tuint256 public constant ICO_FUNDS =\n\t\tMAX_SUPPLY - ECOSYSTEM_DISTRIBUTION_FUNDS;\n}\n"
    },
    "contracts/modules/sht-module/SHTModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"../../lib/TokenPayments.sol\";\nimport \"./SHT.sol\";\n\n/**\n * @title SHTModule\n * @dev This contract manages the Smart Housing Token (SHT) within the platform.\n * It includes functionalities for making payments in SHT and querying the SHT token ID.\n */\nabstract contract SHTModule is ERC20, ERC20Burnable {\n\tfunction decimals() public pure override returns (uint8) {\n\t\treturn uint8(SHT.DECIMALS);\n\t}\n\n\t/**\n\t * @dev Makes an ERC20TokenPayment struct in SHT for and amount.\n\t * @param shtAmount Amount of SHT to be sent.\n\t * @return payment ERC20TokenPayment struct representing the payment.\n\t */\n\tfunction _makeSHTPayment(\n\t\tuint256 shtAmount\n\t) internal view returns (ERC20TokenPayment memory) {\n\t\treturn ERC20TokenPayment(IERC20(address(this)), shtAmount);\n\t}\n}\n"
    },
    "contracts/project-funding/ProjectFunding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"../lib/ProjectStorage.sol\";\nimport \"../lib/LkSHTAttributes.sol\";\n\nimport \"../main/Interface.sol\";\n\nimport \"../housing-project/HousingProject.sol\";\nimport \"../modules/LockedSmartHousingToken.sol\";\nimport \"../modules/sht-module/SHT.sol\";\n\nimport { TokenPayment } from \"../lib/TokenPayments.sol\";\n\n/**\n * @title ProjectFunding\n * @dev This contract is used for initializing and deploying housing projects.\n * It allows the deployment of a new housing project and manages project data.\n */\ncontract ProjectFunding is Ownable {\n\tusing SafeMath for uint256;\n\tusing ProjectStorage for mapping(uint256 => ProjectStorage.Data);\n\tusing ProjectStorage for ProjectStorage.Data;\n\tusing LkSHTAttributes for LkSHTAttributes.Attributes;\n\n\taddress public coinbase; // Address authorized to initialize the first project, also the housingToken\n\taddress public smartHousingAddress; // Address of the SmartHousing contract\n\n\tmapping(uint256 => ProjectStorage.Data) public projects; // Mapping of project ID to ProjectData\n\tmapping(address => uint256) public projectsId; // Mapping of project address to project ID\n\tuint256 public projectCount; // Counter for the total number of projects\n\n\tmapping(uint256 => mapping(address => uint256)) public usersProjectDeposit;\n\n\tIERC20 public housingToken; // Token used for funding projects\n\tLkSHT public lkSht; // The locked version\n\n\t/**\n\t * @dev Emitted when a new project is deployed.\n\t * @param projectAddress Address of the newly deployed HousingProject contract.\n\t */\n\tevent ProjectDeployed(address indexed projectAddress);\n\tevent ProjectFunded(\n\t\tuint256 indexed projectId,\n\t\taddress indexed depositor,\n\t\tTokenPayment payment\n\t);\n\tevent ProjectTokensClaimed(\n\t\taddress indexed depositor,\n\t\tuint256 projectId,\n\t\tuint256 amount\n\t);\n\n\t/**\n\t * @param _coinbase Address authorized to initialize the first project.\n\t */\n\tconstructor(address _coinbase) {\n\t\tcoinbase = _coinbase;\n\t\tlkSht = NewLkSHT.create();\n\t}\n\n\t/**\n\t * @dev Internal function to deploy a new HousingProject contract.\n\t * @param fundingToken Address of the ERC20 token used for funding.\n\t * @param fundingGoal The funding goal for the new project.\n\t * @param fundingDeadline The deadline for the project funding.\n\t */\n\tfunction _deployProject(\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\taddress fundingToken,\n\t\tuint256 fundingGoal,\n\t\tuint256 fundingDeadline\n\t) internal {\n\t\tHousingProject newProject = new HousingProject(\n\t\t\tname,\n\t\t\tsymbol,\n\t\t\tsmartHousingAddress\n\t\t);\n\t\tProjectStorage.Data memory projectData = projects.createNew(\n\t\t\tprojectsId,\n\t\t\tprojectCount,\n\t\t\tfundingGoal,\n\t\t\tfundingDeadline,\n\t\t\tfundingToken,\n\t\t\taddress(newProject),\n\t\t\taddress(newProject.projectSFT())\n\t\t);\n\t\tprojectCount = projectData.id;\n\n\t\temit ProjectDeployed(projectData.projectAddress);\n\t}\n\n\t/**\n\t * @dev Initializes the first project.\n\t * This function must be called by the coinbase address and can only be called once.\n\t * It sets up the token and deploys the first project.\n\t * @param shtPayment Payment details for the Smart Housing Token (SHT).\n\t * @param smartHousingAddress_ Address of the Smart Housing contract.\n\t * @param fundingToken Address of the ERC20 token used for funding.\n\t * @param fundingGoal The funding goal for the new project.\n\t * @param fundingDeadline The deadline for the project funding.\n\t */\n\tfunction initFirstProject(\n\t\tERC20TokenPayment calldata shtPayment,\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\taddress smartHousingAddress_,\n\t\taddress fundingToken,\n\t\tuint256 fundingGoal,\n\t\tuint256 fundingDeadline\n\t) external {\n\t\trequire(msg.sender == coinbase, \"Caller is not the coinbase\");\n\t\trequire(projectCount == 0, \"Project already initialized\");\n\n\t\tTokenPayments.receiveERC20(shtPayment);\n\t\thousingToken = shtPayment.token;\n\n\t\tsmartHousingAddress = smartHousingAddress_;\n\n\t\t_deployProject(\n\t\t\tname,\n\t\t\tsymbol,\n\t\t\tfundingToken,\n\t\t\tfundingGoal,\n\t\t\tfundingDeadline\n\t\t);\n\t}\n\n\t/**\n\t * @dev Deploys a new project.\n\t * This function can be called multiple times to deploy additional projects.\n\t * @param fundingToken Address of the ERC20 token used for funding.\n\t * @param fundingGoal The funding goal for the new project.\n\t * @param fundingDeadline The deadline for the project funding.\n\t */\n\tfunction deployProject(\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\taddress fundingToken,\n\t\tuint256 fundingGoal,\n\t\tuint256 fundingDeadline\n\t) public onlyOwner {\n\t\t_deployProject(\n\t\t\tname,\n\t\t\tsymbol,\n\t\t\tfundingToken,\n\t\t\tfundingGoal,\n\t\t\tfundingDeadline\n\t\t);\n\t}\n\n\tfunction fundProject(\n\t\tTokenPayment calldata depositPayment,\n\t\tuint256 projectId,\n\t\tuint256 referrerId\n\t) external payable {\n\t\trequire(\n\t\t\tprojectId > 0 && projectId <= projectCount,\n\t\t\t\"Invalid project ID\"\n\t\t);\n\n\t\taddress depositor = msg.sender;\n\n\t\t// Register user with referrer (if needed)\n\t\tISmartHousing(smartHousingAddress).createRefIDViaProxy(\n\t\t\tdepositor,\n\t\t\treferrerId\n\t\t);\n\n\t\t// Update project funding\n\t\tprojects.fund(\n\t\t\tusersProjectDeposit[projectId],\n\t\t\tprojectId,\n\t\t\tdepositor,\n\t\t\tdepositPayment\n\t\t);\n\n\t\temit ProjectFunded(projectId, depositor, depositPayment);\n\t}\n\n\tfunction addProjectToEcosystem(uint256 projectId) external onlyOwner {\n\t\tProjectStorage.Data storage project = projects[projectId];\n\n\t\t// TODO Add this after demo\n\t\t// require(\n\t\t// \tproject.status() == ProjectStorage.Status.Successful,\n\t\t// \t\"Project Funding not yet successful\"\n\t\t// );\n\n\t\tISmartHousing(smartHousingAddress).addProject(project.projectAddress);\n\n\t\tHousingProject(project.projectAddress).setTokenDetails(\n\t\t\tproject.collectedFunds,\n\t\t\tcoinbase\n\t\t);\n\t}\n\n\t/**\n\t * @dev Claims project tokens for a given project ID.\n\t * @param projectId The ID of the project to claim tokens from.\n\t */\n\tfunction claimProjectTokens(uint256 projectId) external {\n\t\taddress depositor = msg.sender;\n\n\t\t// Retrieve the project and deposit amount\n\t\t(ProjectStorage.Data memory project, uint256 depositAmount) = projects\n\t\t\t.takeDeposit(usersProjectDeposit[projectId], projectId, depositor);\n\n\t\tHousingSFT(project.tokenAddress).mintSFT(\n\t\t\tdepositAmount,\n\t\t\tdepositor,\n\t\t\tproject.collectedFunds\n\t\t);\n\n\t\t// Mint LkSHT tokens if the project ID is 1\n\t\tif (project.id == 1) {\n\t\t\tuint256 shtAmount = depositAmount.mul(SHT.ICO_FUNDS).div(\n\t\t\t\tproject.collectedFunds\n\t\t\t);\n\n\t\t\tlkSht.mint(shtAmount, depositor);\n\t\t}\n\n\t\temit ProjectTokensClaimed(depositor, projectId, depositAmount);\n\t}\n\n\tfunction unlockSHT(uint256 nonce) external {\n\t\taddress caller = msg.sender;\n\n\t\tuint256 lkShtBal = lkSht.balanceOf(caller, nonce);\n\t\trequire(lkShtBal > 0, \"ProjectFunding: Nothing to unlock\");\n\n\t\tLkSHTAttributes.Attributes memory attr = abi.decode(\n\t\t\tlkSht.getRawTokenAttributes(nonce),\n\t\t\t(LkSHTAttributes.Attributes)\n\t\t);\n\t\t(\n\t\t\tuint256 totalUnlockedAmount,\n\t\t\tLkSHTAttributes.Attributes memory newAttr\n\t\t) = attr.unlockMatured();\n\n\t\tlkSht.update(\n\t\t\tcaller,\n\t\t\tnonce,\n\t\t\tlkShtBal.sub(totalUnlockedAmount),\n\t\t\tabi.encode(newAttr)\n\t\t);\n\n\t\t// Transfer the total unlocked SHT tokens to the user's address\n\t\tif (totalUnlockedAmount > 0) {\n\t\t\thousingToken.transfer(caller, totalUnlockedAmount);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns an array of all project IDs and their associated data.\n\t * @return projectList An array of tuples containing project details.\n\t */\n\tfunction allProjects() public view returns (ProjectStorage.Data[] memory) {\n\t\tProjectStorage.Data[] memory projectList = new ProjectStorage.Data[](\n\t\t\tprojectCount\n\t\t);\n\n\t\tfor (uint256 i = 1; i <= projectCount; i++) {\n\t\t\tprojectList[i - 1] = projects[i];\n\t\t}\n\n\t\treturn projectList;\n\t}\n\n\t/**\n\t * @dev Returns the address of the HousingProject contract for a given project ID.\n\t * @param projectId The ID of the project.\n\t * @return projectAddress The address of the HousingProject contract.\n\t */\n\tfunction getProjectAddress(\n\t\tuint256 projectId\n\t) external view returns (address projectAddress) {\n\t\tProjectStorage.Data storage project = projects[projectId];\n\t\treturn project.projectAddress;\n\t}\n\n\t/**\n\t * @dev Returns the details of a project by its ID.\n\t * @param projectId The ID of the project.\n\t * @return id The project ID.\n\t * @return fundingGoal The funding goal of the project.\n\t * @return fundingDeadline The deadline for the project funding.\n\t * @return fundingToken The address of the ERC20 token used for funding.\n\t * @return projectAddress The address of the HousingProject contract.\n\t * @return status The funding status of the project.\n\t * @return collectedFunds The amount of funds collected.\n\t */\n\tfunction getProjectData(\n\t\tuint256 projectId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 id,\n\t\t\tuint256 fundingGoal,\n\t\t\tuint256 fundingDeadline,\n\t\t\taddress fundingToken,\n\t\t\taddress projectAddress,\n\t\t\tuint8 status,\n\t\t\tuint256 collectedFunds\n\t\t)\n\t{\n\t\tProjectStorage.Data storage project = projects[projectId];\n\t\treturn (\n\t\t\tproject.id,\n\t\t\tproject.fundingGoal,\n\t\t\tproject.fundingDeadline,\n\t\t\tproject.fundingToken,\n\t\t\tproject.projectAddress,\n\t\t\tuint8(project.status()),\n\t\t\tproject.collectedFunds\n\t\t);\n\t}\n}\n"
    },
    "contracts/test-artifacts/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract MintableERC20 is ERC20, Ownable, ERC20Burnable {\n\tconstructor(\n\t\tstring memory name_,\n\t\tstring memory symbol_\n\t) ERC20(name_, symbol_) {}\n\n\tfunction mint(address to, uint256 amt) external onlyOwner {\n\t\t_mint(to, amt);\n\t}\n}\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "prb-math/contracts/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}